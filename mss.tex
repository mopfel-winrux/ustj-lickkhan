\documentclass[twoside]{article}

\usepackage{ustj}

%\newcommand{\authorname}{}
\newcommand{\authorpatp}{\patp{mopfel-winrux}}
\newcommand{\affiliation}{Native Planet}

%  Make first page footer:
\fancypagestyle{firststyle}{%
\fancyhf{}% Clear header/footer
\fancyhead{}
\fancyfoot[L]{{\footnotesize
              %% We toggle between these:
              Manuscript submitted for review.\\
              % {\it Urbit Systems Technical Journal} I:1 (2024):  1–3. \\
              ~ \\
              Address author correspondence to \authorpatp.
              }}
}
%  Arrange subsequent pages:
\fancyhf{}
\fancyhead[LE]{{\urbitfont Urbit Systems Technical Journal}}
\fancyhead[RO]{What Hast Earth to do With Mars}
\fancyfoot[LE,RO]{\thepage}

%%MANUSCRIPT
\title{What Hast Earth to do With Mars: An explanation of Urbit's IPC interfaces}
\author{~\authorpatp \\ \affiliation}
\date{}

\begin{document}

\maketitle
\thispagestyle{firststyle}

\begin{abstract}
In this groundbreaking paper, we embark on a cosmic journey with the renowned character Ernest P. Worrell as he ventures into the unexplored realm of Martian computing. Drawing inspiration from Ernest's comically ingenious encounters with everyday challenges, we investigate the foundations of what we term "Artificial Stupidity." As Ernest grapples with Martian technology, we delve into the intricacies of programming errors, algorithmic missteps, and the curious phenomena that arise when human-like intelligence meets extraterrestrial computing systems. Our analysis sheds light on the unexpected intersections between humor, artificial intelligence, and the cosmic absurdity of Martian software. Join us in this interplanetary exploration as we unravel the mysteries of Artificial Stupidity through the lens of Ernest's interstellar escapades.
\end{abstract}

% We will adjust page numbering in final editing.
\pagenumbering{arabic}
\setcounter{page}{1}

\tableofcontents

\section{Introduction}

In the realm of software, two worlds exist in stark contrast: 
Earth, the familiar domain of established software paradigms, bustling with complex and varied digital ecosystems, 
and Mars, the enigmatic realm of Urbit, a system as pristine and archaic as the Martian landscape itself. 
This article sets forth on an expedition to unravel the mysteries of this Martian software landscape, 
exploring how the intricate processes of terrestrial technology can establish a dialogue with the Martian code.

Unlike Earth, where software is a tapestry of evolution and patchwork, Mars presents a realm of purity. 
It is a world where software exists as a Maxwellian construct, untouched and unaltered by the non-Maxwellian intricacies that characterize Earth’s digital environments. 
Yet, in this isolation lies a profound awareness - an understanding by the Martians that there exist diverse forms of computing with which they must engage. 
Mars, in its wisdom, accommodates these external entities, allowing them to interact in a dialect familiar to its inhabitants: the language of nouns.

Our journey into this uncharted territory begins with a deep dive into the architecture of Urbit, focusing on the foundational layer upon which Arvo, Urbit's kernel, operates.
This exploration will illuminate the operational dynamics and philosophical underpinnings that make Urbit a universe apart. 
Following this, we delve into the intricacies of two pivotal components of Urbit’s ecosystem: 
\texttt{\%khan} and \texttt{\%lick}. 
These vanes serve as distinct conduits between the terrestrial and the Martian, facilitating not just interaction but a nuanced form of control and collaboration with Arvo.
Through this exploration, we aim to demystify the enigma of Urbit and bridge the cosmic gap between Earth’s established software paradigms and the Martian vision of computational purity and simplicity.

\section{Urbit's Unique Landscape}

\subsection{Arvo: The Heart of Martian Computing}
Arvo, also known as Urbit OS, represents a paradigm shift in operating system design. Unlike traditional operating systems that operate on preemptive multitasking and complex event networks, Arvo is a purely functional operating system, characterized by its deterministic nature and compact size. The entire Urbit stack is about 30,000 lines of code, with Arvo itself being only around 1,000 lines. This small codebase is intentional, reflecting a philosophy that system administration complexity is directly proportional to code size.

Arvo's design philosophy positions it not just as an operating system but as a new frontier in the peer-to-peer internet space. Unlike traditional operating systems like Windows, macOS, or Linux, Arvo doesn't aim to replace them; instead, it offers a unique user experience akin to a web browser, yet it is a fully-fledged OS in its own right. This distinctive approach enables Arvo to function within a virtual machine, theoretically capable of running on bare metal.

Arvo's unique architecture avoids what is referred to as "event spaghetti" by maintaining a clear causal chain for every computation. Each chain begins with a Unix I/O event and progresses through a series of steps until the computation's terminal cause. This deterministic nature allows for a high level of predictability and control, a stark contrast to the non-deterministic nature of most Earth-based operating systems.

The kernel's design as a "purely functional operating system" – or more accurately, an "operating function" – underscores its uniqueness. Arvo operates on the principle that the current state is a pure function of its event log, a record of every action ever performed. This determinism is a significant deviation from the norm, where operating systems allow for programmatic alteration of global variables affecting other programs.

Arvo handles nondeterminism in an innovative way. The system, in essence, behaves like a stateful packet transceiver – events are processed, but there's no guarantee of completion, mirroring the behavior of packet dropping in networking. This approach to handling nondeterminism is unique and aligns with Arvo's overall philosophy of simplicity and determinism.

Arvo's determinism is a key feature, stacking it atop a frozen instruction set known as Nock. This concept, though new to operating systems, is not foreign to computing. Similar to how CPU instruction sets like x86-64 are frozen at the chip level, Arvo freezes the instruction set at a higher level, enabling deterministic computation. This high-level determinism contrasts sharply with the non-determinism typically found in Earth's operating systems.

Handling nondeterminism in Arvo is akin to a heuristic decision-making process similar to dropping a packet in networking. This approach views Arvo as a stateful packet transceiver, where the completion of events is not guaranteed, a stark difference from traditional computing models. Additionally, because Arvo runs on a VM, it can obtain nondeterministic information, such as stack traces from infinite loops, through the interpreter beneath it, further enhancing its operational capabilities.

The vision of Urbit, with Arvo at its core, is to transition from developer-hosted web services on multiple foreign servers to self-hosted applications on a personal server. Each architectural decision in Arvo aligns with this vision, emphasizing user ownership and management of data. This approach sets it apart from the conventional model of cloud-based services and centralized data management prevalent in Earth-based systems.

\subsection{Vere: The Substrate of Martian Technology}

Vere, the runtime of Urbit, plays a critical role in actualizing the Martian computing model on Earth-based hardware. As the Nock interpreter written in C, Vere is intricately optimized to run Arvo, ensuring seamless translation of its deterministic operations into practical execution on conventional systems.

Key to Vere's functionality is how it processes events. Events from the Unix environment are passed to Vere, which then translates and injects them into Arvo. This mechanism demonstrates a profound integration between Vere and Arvo, where Vere possesses direct knowledge of Arvo's state. Notably, Vere can 'scry' or query Arvo's state without altering it, retrieving information as needed. This capability allows Vere to maintain the integrity of Arvo's deterministic model while enabling dynamic interaction with the outside world.

Urbit's use of Unix as its BIOS is a pivotal aspect of its runtime operation. By leveraging the robust, widely-used Unix system, Vere ensures that Urbit can run on a broad range of hardware platforms, effectively making Urbit's Martian technology accessible and operable in Earth's diverse computing environments. This strategic use of Unix not only provides the necessary I/O and optimizations for Arvo but also ensures that Urbit's advanced and unique software architecture can function in tandem with the existing, established hardware and software ecosystems of Earth.

Moreover, Vere's design allows it to inject events into Arvo, a feature crucial for maintaining the fluid communication and interaction between the Urbit system and its underlying hardware and software infrastructure. This bidirectional communication channel ensures that Arvo can respond to external stimuli while remaining true to its functional and deterministic nature. 

Thus, Vere serves as more than just a bridge between Martian technology and Earthly hardware; it is a finely tuned conduit, optimized to uphold and facilitate the unique computational paradigm that Arvo embodies.


\section{Khan - The High-Level Thread Interface of Urbit}

Khan, as a crucial component of Urbit's architecture, functions as a high-level thread interface, pivotal for managing both internal and external communications within the Urbit ecosystem. It is designed to efficiently handle complex I/O operations, employing an IO monad coupled with an exception monad. This dual-mechanism approach allows Khan to adeptly manage complex IO tasks while effectively handling potential failures.

Khan's role in Urbit can be likened to that of a control plane. Its primary function is to execute threads via a Unix Socket and relay the results back. This setup supports various thread-running modes, enhancing the flexibility of Urbit's computing environment and allowing for diverse interaction methods with both internal and external processes.

At its core, Khan's design revolves around the use of 'threads', which are monadic functions designed to handle arguments and produce results. These threads are optimized for I/O operations, leveraging the IO monad for structured and efficient task handling. The exception monad further ensures robust management of potential failures and unexpected events.

Khan's implementation ensures that Urbit serves as a personal server, replacing multiple developer-hosted web services on foreign servers with self-hosted applications on a single personal server. Its design underscores Urbit's commitment to user ownership and data management, setting it apart from the conventional model of cloud-based services and centralized data management prevalent in Earth-based systems.

\section{\texttt{conn.c}} %Rewrite so its not a blatant copy of alex's work

\texttt{conn.c}\footnote{\url{https://github.com/urbit/vere/blob/develop/pkg/vere/io/conn.c}} is a driver in Vere. It is a part of the "King" (a.k.a. "Urth") process. It exposes a \texttt{Unix domain socket}\footnote{\url{https://en.wikipedia.org/wiki/Unix_domain_socket}} at \texttt{/path/to/pier/.urb/conn.sock} for sending/receiving data from external processes.

The functionality of conn.c, particularly its ability to dispatch messages and handle various types of requests, is critical for the command of urbit's control plane. It serves as a way for unix processes to receive insights about what is happening on urbit. It also allows for pass commands either \%khan and the injection of raw kernel moves into the system. The implication of this means that whoever is running your urbit runtime controls your urbit. 

From a technical perspective, conn.c accepts newt-encoded \texttt{++jam}med nouns which take the form \texttt{[request-id command arguments]}. This structure allows for a variety of commands to be executed, including 

\begin{enumerate}
  \item \texttt{\%ovum} - the injection of raw kernel moves 
  \item \texttt{\%fyrd} - a direct shortcut to Khan commands
  \item \texttt{\%urth} - runtime subcommands like \texttt{\%pack}` or \texttt{\%meld}
  \item \texttt{\%peek} - namespace scry requests into Arvo
  \item \texttt{\%peel} - emulated namespace scry requests into Vere
\end{enumerate}

A valid \texttt{conn.c} command produces a newt-encoded jammed noun with type \texttt{[request-id output]}, where:
\begin{itemize}
  \item \texttt{request-id} matches the input \texttt{request-id}
  \item \texttt{output} depends on the \texttt{command}
\end{itemize}

An invalid \texttt{conn.c} command produces a newt-encoded jammed noun with type \texttt{[0 \%bail error-code error-string]}. 

\subsection{\%ovum}

The argument to an \texttt{\%ovum} command is a raw kernel move which is injected directly into the Arvo event loop. This is a very powerful - and potentially dangerous - tool. For example, if a ship somehow got into a state where Clay was no longer working properly (meaning new files could not be compiled to fix the state of the kernel), the source code for a new, working Clay could be directly injected into the ship using an \texttt{\%ovum}.

The output of an \texttt{\%ovum} command is:
\begin{itemize}
  \item \texttt{[\%news \%done]} if the move completed successfully
  \item \texttt{[\%news \%drop]} if the move was dropped
  \item \texttt{[\%bail goof]} if an error occurred
\end{itemize}

\subsection{\%fyrd}

\texttt{\%fyrd} is a direct shortcut to the Khan vane. The arguments to a \texttt{\%fyrd} command are (in order):
\begin{enumerate}
  \item The name of the desk in which the thread lives (e.g. \texttt{\%base}) or \texttt{beak} for the thread (e.g. \texttt{[\%zod \%base \%10]})
  \item The name of the thread (e.g. \texttt{\%hi})
  \item Mark to which the output should be cast (e.g. \texttt{\%tape})
  \item Mark for how to interpret the input argument to thread (e.g. \texttt{\%ship})
  \item Input argument to thread (e.g. \texttt{\~zod})
\end{enumerate}

The output of a \texttt{\%fyrd} command is \texttt{[\%avow (each page goof)]}, the value of \texttt{each} depending on whether the thread succeeded or not.

\subsection{\%urth}

The argument to the \texttt{\%urth} command is a subcommand for the action to perform. Currently, the only valid commands are \texttt{\%pack} and \texttt{\%meld}.

\texttt{\%urth} will return \texttt{\%\&} if given a valid command as input, otherwise it will return \texttt{[0 \%bail 0xfffffff9 \%urth-bad]}. No other output is emitted.

\subsection{\%peek}

The \texttt{\%peek} command is used to perform a namespace read request (a.k.a. scry) using Arvo's external peek interface \texttt{arm +22 in arvo.hoon}\footnote{\url{https://github.com/urbit/urbit/blob/develop/pkg/arvo/sys/arvo.hoon#L1774}}. The argument to \texttt{\%peek} is the \texttt{nom} input to \texttt{+peek} in \texttt{arvo.hoon} (\texttt{lyc} is auto-filled as \texttt{[~ ~]}, i.e., "request from self"). That is to say that the argument to \texttt{\%peek} must have type:
\begin{verbatim}
$+  each  path
$%  [%once vis=view syd=desk tyl=spur]
    [%beam vis=view bem=beam]
==
\end{verbatim}
Practically speaking, this means that the input will look like one of these three examples:
\begin{verbatim}
[%& p=path]
[%| p=[%once vis=view syd=desk tyl=spur]]
[%| p=[%beam vis=view bem=beam]]
\end{verbatim}
Where:
\begin{itemize}
  \item \texttt{path} is a \texttt{[view beam]}, with the \texttt{view} passed in as a \texttt{coin}
  \item \texttt{view} is the vane code for the scry, as well as an optional care, possibly appended to the vane (e.g. \texttt{\%j}, \texttt{\%gx}, etc.)
  \item \texttt{beam} is a \texttt{[beak spur]}
  \item \texttt{desk} is used to auto-generate a \texttt{beak}: \texttt{[our desk now]}
  \item \texttt{spur} is the scry endpoint for the agent or vane
\end{itemize}

The output of a \texttt{\%peek} command is \texttt{[\%peek (unit (unit scry-output))]}, where \texttt{~} means that the scry endpoint is invalid, and \texttt{[~ ~]} means that the scry resolved to nothing.

\subsection{\%peel}

\texttt{\%peel} attempts to emulate a scry-like namespace, like the one used by Arvo and accessed by \texttt{\%peek}. The argument to \texttt{\%peel} should be a path. Valid paths result in a non-null \texttt{unit} containing the result of the scry. Invalid paths result in null (i.e. \texttt{~}). The valid paths and the data they return are:

\begin{verbatim}
/help   (unit (list path))  Supported %peel paths
/live   (unit ~)            Pier health check; succeeds if pier is running
/khan   (unit ~)            Khan health check; succeeds if Khan vane is running
/info   (unit mass)         Pier info as a mass
/v      (unit @t)           Returns version of the Vere binary as a cord
/who    (unit @)            Returns the Azimuth identity of the ship as an atom
\end{verbatim}

Note that the pier info above is returned as a \texttt{mass} report, i.e. type \texttt{(pair cord (each * (list mass)))}. This is not the same as the \texttt{|mass} memory report. \texttt{/mass} is meant to be a valid \texttt{\%peel} path which returns the \texttt{|mass} memory report, but it is currently unimplemented.

\section{\%lick}

Altho also dealing with interprocess communication, Lick was designed for a very different scenario than Khan:  to allow external processes, in particular hardware drivers, to intercommunicate with Urbit.  (This breached the Earth/Mars divide.)  Thus \texttt{/sys/vane/lick} focuses on instrumenting a low-level noun interfaces over domain sockets.

\texttt{\%lick} manages IPC ports, and the communication between Urbit applications and POSIX applications via these ports. Other vanes and applications ask \texttt{\%lick} to open an IPC port, notify it when something is connected or disconnected, and transfer data between itself and the Unix application.

Lick works by opening a Unix socket for a particular process, which allows serialized IPC communications.  These involve a jammed noun so the receiving process needs to know how to communicate in nouns.

The IPC ports Lick creates are Unix domain sockets (\texttt{AF\_UNIX} address family) of the \texttt{SOCK\_STREAM} type.

The connexions are made via filepaths in \texttt{.urb/dev} of the pier.

The format is:

\begin{verbatim}
V.BBBB.JJJJ.JJJJ...
\end{verbatim}

\begin{itemize}
  \item \texttt{V} is the version
  \item \texttt{B} is the jam size in bytes (little endian)
  \item \texttt{J} is the jammed noun (little endian)
\end{itemize}

The process on the host OS must therefore strip the first 5 bytes, \texttt{++cue}\footnote{\url{https://docs.urbit.org/language/hoon/reference/stdlib/2p#cue}} the jamfile, check the mark and (most likely) convert the noun into a native data structure.

\subsection{\texttt{/sys/lull} Definition}

\begin{verbatim}
::                                              ::::
::::                    ++lick                    ::  (1j) IPC
  ::                                            ::::
++  lick  ^?
  |%
  +$  gift                                      ::  out result <-$
    $%  [%spin =name]                           ::  open an IPC port
        [%shut =name]                           ::  close an IPC port
        [%spit =name =mark =noun]               ::  spit a noun to the IPC port
        [%soak =name =mark =noun]               ::  soak a noun from the IPC port
    ==
  +$  task                                      ::  in request ->$
    $~  [%vega ~]                               ::
    $%  $>(%born vane-task)                     ::  new unix process
        $>(%trim vane-task)                     ::  trim state
        $>(%vega vane-task)                     ::  report upgrade
        [%spin =name]                           ::  open an IPC port
        [%shut =name]                           ::  close an IPC port
        [%spit =name =mark =noun]               ::  spit a noun to the IPC port
        [%soak =name =mark =noun]               ::  soak a noun from the IPC port
    ==
  ::
  +$  name  path
  --  ::lick
\end{verbatim}

To evaluate what \texttt{/sys/vane/lick} is doing, we need to look at Unix's IPC model briefly.  IPC ("interprocess communication") describes any way that two processes in an operating system's shared context have to communicate with each other.  \texttt{\%lick} focuses on Unix domain sockets\footnote{\url{https://en.wikipedia.org/wiki/Unix_domain_socket}}, which are just communication endpoints\footnote{\url{https://man7.org/linux/man-pages/man7/unix.7.html}}.

For instance, a valid use of \texttt{\%lick} would use cards that look like this:

\begin{verbatim}
++  init  [[%pass / %arvo %l %spin /control]~ this]
::
++  on-arvo
  |=  [=wire =sign-arvo]
  ?+  sign-arvo  (on-arvo:def wire sign-arvo)
      [%lick %soak *]
      ?+  mark.sign-arvo  [~ this]
      ::
        %connect
      ~&  >  "connect"
      :_  this  [%pass /spit %arvo %l %spit /control %init area.state]~
  ==  ==
::
++  send-state
  |=  =state
  ^-  card:agent:gall
  [%pass /spit %arvo %l %spit /control %state [slick:state face.state food.state live.state]]
\end{verbatim}

The vane definition of \texttt{/sys/vane/lick} is even simpler than \texttt{/sys/vane/khan}:  it has no \texttt{++abet} core and primarily communicates to the \texttt{unix-duct} in its state.  The \texttt{owner} is a \texttt{duct} to handle the return \texttt{\%soak}.

Gall needs to wrap \texttt{\%soak} and \texttt{\%spit} to route properly.  See e.g. \texttt{\%++ap-generic-take}.  This lets multiple agents share sockets with the same name, and each agent can have its own folder.

%\section{Background and Literature}

%Exposite the relevant background and literature.

%\begin{enumerate}
  %\item  Prefer to \texttt{enumerate}.
  %\item  It is easier to refer to than \texttt{itemize}.
%\end{enumerate}

%\noindent
%Mark \texttt{\textbackslash noindent} in paragraphs that continue the thought of an \texttt{\textbackslash enumerate} block.
%
%\section{Urbit's Implementation}
%
%Oftentimes you will then turn to exploring how Urbit or closely related systems like Nockchain have approached or considered a problem.
%
%\lstset{language=C}
%\begin{lstlisting}
%#include <stdio.h>
%
%double compute(float a, float b) {
    %return a * a + b * b;
%}
%
%int main() {
    %float x = 2.5;
    %float y = 3.7;
%
    %double result = compute(x, y);
%
    %printf("Result: %lf\n", result);
%
    %return 0;
%}
%\end{lstlisting}
%
%\noindent
%That code snippet was part of the text, and not a standalone entity to which we make separate repeated reference.
%
%\begin{figure}
  %\begin{lstlisting}[language=Python, caption={Example Python Code}, label={lst:example}]
  %def hello_world():
      %print("Hello, world!")
  %\end{lstlisting}
%\end{figure}
%
%Refer to the code listing: Listing~\ref{lst:example}.  (Note that we don't suppress indentation since it's a float.)
%

%\section{A Wild Ernest Appears}
%
%You can have as many sections as make sense.  Only sections and subsections appear in the table of contents.
%
\section{Conclusion}

To summarize, why did you write it?  Why do we care?  What impact should it have on Urbit development?

Your bibliography is a separate BibTeX file.  We use the \texttt{plainnat} bibliography style.  You can use \texttt{natbib} citation commands like \texttt{\textbackslash citep\{wikipedia\}} for parenthesized references.  Use \texttt{\textbackslash citet\{wikipedia\}} for inline references.  You can also use \texttt{\textbackslash citeauthor\{wikipedia\}} for the principal author's name.

``You can use traditional TeX---or LaTeX---representations'' \citep{Varney1987}.

“Or you can use fancy quotes—and symbols.”

\bibliographystyle{plainnat}
\bibliography{ernest}
\end{document}
